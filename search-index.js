var N=null,E="",T="t",U="u",searchIndex={};
var R=["abomonation","option","ioresult","abomonation::abomonated","result","Abomonated","Abomonation"];

searchIndex[R[0]]={"doc":"Abomonation (spelling intentional) is a fast serialization…","i":[[5,"encode",R[0],"Encodes a typed reference into a binary buffer.",N,[[[T],["w"]],[R[2]]]],[5,"decode",E,"Decodes a mutable binary slice into an immutable typed…",N,[[],[R[1]]]],[5,"measure",E,"Reports the number of bytes required to encode `self`.",N,[[[T]],["usize"]]],[0,"abomonated",E,E,N,N],[3,R[5],R[3],"A type wrapping owned decoded abomonated data.",N,N],[11,"new",E,"Attempts to create decoded data from owned mutable bytes.",0,[[["s"]],[R[1]]]],[11,"as_bytes",E,E,0,[[["self"]]]],[8,R[6],R[0],"Abomonation provides methods to serialize any heap data…",N,N],[11,"entomb",E,"Write any additional information about `&self` beyond its…",1,[[["self"],["w"]],[R[2]]]],[11,"exhume",E,"Recover any information for `&mut self` not evident from…",1,[[["self"]],[R[1]]]],[11,"extent",E,"Reports the number of further bytes required to entomb…",1,[[["self"]],["usize"]]],[14,"unsafe_abomonate",E,"The `unsafe_abomonate!` macro takes a type name with an…",N,N],[11,"from",R[3],E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,"try_from",E,E,0,[[[U]],[R[4]]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,"type_id",E,E,0,[[["self"]],["typeid"]]],[11,"borrow_mut",E,E,0,[[["self"]],[T]]],[11,"try_into",E,E,0,[[],[R[4]]]],[11,"deref",E,E,0,[[["self"]],[T]]]],"p":[[3,R[5]],[8,R[6]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);